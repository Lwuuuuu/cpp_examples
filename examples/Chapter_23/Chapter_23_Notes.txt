Templates provide direct suppport f or generic programming in the f orm of p rogramming using types as parameters 
    Provides a straightforward way to represent a wide range of general concepts and simple w ays to d efine them
    The resulting classes and functions can match handwritten, less general code in run-time and space effiency 
A template only depends on properties that it actually uses f rom its parameter types and does not r equire types used as rguments to be explicitly related.
    A template's requirements on its a rguments cannot be simply and  directly stated in code 

C++ does not offer a direct way to say what kind of type a template argument C is suppose to be 
A class generated from a class te mplate is a prefectly ordinary class. 
    A template is a specification of how to generate something given stuiable tempalte arguments. 
Good idea t o debug a particular class b efore t urning it into a template 

Template Instantiation 
    The process  of generating a class or a function from a template plus a  template argument list is often called template instantiation 
    A version of a template for a  specific template argument list is called a specialization 
In general, it is the implementation's job to ensure that specialization of a tempalte are generated for each template argument list used 

Usage of templates enable inlining of ti ny functions that can lead t o significant code shrinkage compared to alternatives 

Type Checking 
    Flexibility in templates implies complexity of type checking and difficulties for accurate reporting of type errors  
    Type checking is done on the code generated by template instaniation 

Type Equivalence 
    Types generated from a single template by d ifferent template arguments are to be considered diffeerent t ypes 

Error Detection 
    A template is defined and then later used in combination with a set of template arguments 
        When the template is defined, the definition is c hecked for syntax errors and possibly also for other errors that can be detected in isolation from a particular set of template arguments 

static Members  
    A static data or function member t hat is not defined in-class must have a unique definition in a program 

Member Templates 
    A class or a class template can ha ve members that are themselves templates.
        Allows us to represeent related types with a pleasing degree of control and flexibility 
Avoid nested  types in templates unless they genuinely rely on every template parameter  

Friends 
    Template class can desginate functions as friends 
    The <> after the name of the friend  functions is needed to m ake clear that the friend is a template function 
        Multiplcation operator can then be defined to access data from Vector and Matrix 
    Friends to not affect the s cope in which the template class is defined 
        Friend functions and operator are found using a lookup based on their argument types 
        Only instaniated o nly if it is used 
    A class template  can desginate other classes as friends 
    Friends that  depend on a template argument For Example - 
    template<typename T>
        Class my_other_class { 
            friend T;
            friend My_class<T>;
            friend class T; //error, redudant class 
        }
    friendship is not transitive or inherited. 
        For example - C has not become a friend of My_other_class<int> even though My_class<int> is a friend and C is a friend of my_class<int>
    Cannot directly make a template a friend of a  class, but we can make a friend declaration a template 

Function Templates 
    Need for function template arises to manipulate containers that were defined using templates 
    Tempalte arguments are deduced from the function arguments 

    Not all  types have a <  operator, which l imits the use of this version of sort() 
    Can avoid this limitation by using the following 
        template<typename  T, typename Compare = std::less<T>>
    If we need to create an object of a d edeuced type, we often do that by calling a fu nction to do the deduction 
    If a template argument cannot be deduced from the  function arguments, must specify  it explitictly 
    Example - 
        template<typename T, typename  U> 
        void f(const T*, U(*)(U)); //Function Argument 
        int g(int);
        void h(const char* p) { 
            f(p,g); T is char, U is int because G returns an  int 
            f(p,h); Cannot deduce the type of U because h()'s argument and return type differ from U(*)(U)

        }

Reference Deduction 
    Lvalues and Rvalues are distinguished by template argument deteuction 
        An l value of type X is deduced as an X& and an rvalue as X \    
691/706 